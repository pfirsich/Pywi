import numpy as npimport pywi as pwimport time	def circleHitCircle(centerA, centerB, radiusA, radiusB):	rel = centerA - centerB	rsum = radiusA + radiusB	return np.dot(rel,rel) < rsum*rsum	class CacheGroup(object):	def __init__(self):		self.index = 0			def invalidate(self):		self.index += 1class CollisionConvexPolygon(object):	def __init__(self, polygon, transform, cacheGroup = None):		self.polygon = polygon		self.transform = transform		self.cacheGroup = cacheGroup		if self.cacheGroup != None:			self.lastCache = self.cacheGroup.index		self._transformedPolygon = self.polygon.transformed(self.transform)			def invalidateCache(self):		self.lastCache = -1				def transformedPolygon(self):		if self.cacheGroup != None and self.lastCache != self.cacheGroup.index:			self._transformedPolygon = self.polygon.transformed(self.transform)			self.lastCache = self.cacheGroup.index		return self._transformedPolygon			def hit(self, other):		centerA = self.transformedPolygon()._centroid		centerB = other.transformedPolygon()._centroid		radiusA = self.transformedPolygon()._radius		radiusB = other.transformedPolygon()._radius		if not circleHitCircle(centerA, centerB, radiusA, radiusB):			return None		return self.transformedPolygon().collidesPolygon_convex(other.transformedPolygon())		class Circle(object):	def __init__(self, center, radius):		self.center = center		self.radius = radius			def pointInSphere(point):		rel = self.center - point		return np.dot(rel,rel) <= self.radius*self.radius			def hitCircle(other):		return circleHitCircle(self.center, other.center, self.radius, other.radius)class Ray(object):	def __init__(self, origin, dir):		self.origin = origin		self.dir = dir			def hitRay(self, other):		if np.linalg.det([self.dir, other.dir]) == 0:			return None					# Solve "self.origin + self.dir*s = other.origin + self.dir*t" for s and t		res = np.linalg.solve( pw.vec2([self.dir[0], -other.dir[0]], [self.dir[1], -other.dir[1]]), other.origin - self.origin )		return res		def eval(self, t):		return self.origin + self.dir * t			def hitTriangle(self, tri):		# check ray hit with all edges and check if they are in range [0,1] (between to points)		a = self.hitRay( Ray( tri[0], tri[1] - tri[0] ) )		b = self.hitRay( Ray( tri[1], tri[2] - tri[1] ) )		c = self.hitRay( Ray( tri[2], tri[0] - tri[2] ) )				results = []		if (a != None and 0 <= a[1] <= 1 and a[0] > 0):			results.append(a[0])		if (b != None and 0 <= b[1] <= 1 and b[0] > 0):			results.append(b[0])		if (c != None and 0 <= c[1] <= 1 and c[0] > 0):			results.append(c[0])		if len(results) >= 2:			return min(results)		else:			return None				# ALTERNATIVE: project all points on a vector perpendicular to the rays direction		"""		a = tri[0] - self.origin		b = tri[1] - self.origin		c = tri[2] - self.origin		axis = orthoVector(self.dir / self.dir.norm())		p = [projectOnAxis(axis, a), projectOnAxis(axis, b), projectOnAxis(axis, c)]		mi = min(p)		ma = max(p)		return mi < 0 and ma > 0		"""		